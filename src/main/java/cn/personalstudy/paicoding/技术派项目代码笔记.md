# MyBatisPlus使用
查询一条数据时，可以使用.last("limit 1")，这样可以避免查询出多条数据，但是需要注意的是，使用last("limit 1")可能会导致查询效率低下，因为它会查询出所有数据，然后再取第一条数据，所以在使用时需要注意。
```java
public UserDO getUserByUserName(String userName) {
    LambdaQueryWrapper<UserDO> queryUser = Wrappers.lambdaQuery();
    queryUser.eq(UserDO::getUserName, userName)
            .eq(UserDO::getDeleted, YesOrNoEnum.NO.getCode())
            .last("limit 1");
    return userMapper.selectOne(queryUser);
}
```

# 实体类字段上注解
@TableId 是MyBatisPlus框架提供的注解，用于指定数据库表的主键字段，IdType代表不同的主键生成策略。
```java
@TableId(type = IdType.AUTO)
private Long id;
```
IdType的取值如下：
- AUTO(0)：自动生成主键，根据数据库的自增策略来生成主键。
- NONE(1)：不指定主键，由开发者手动设置主键。
- INPUT(2)：由开发者手动输入主键值。
- ASSIGN_ID(3)：使用雪花算法生成主键，并将主键转换为字符串类型。
- ASSIGN_UUID(4)：使用UUID生成主键，并将主键转换为字符串类型。


# Serializable接口
Serializable接口是Java语言提供的一个接口，用于标识一个类可以进行序列化。Serializable接口本身没有定义任何方法，它只是一个标记接口，用于告诉JVM这个类可以被序列化。
当一个类实现了Serializable接口后，它的对象就可以被序列化和反序列化。序列化是将对象转换为字节流的过程，反序列化是将字节流转换为对象的过程。

在反序列化时，Java虚拟机会比较序列化对象中的serialVersionUID和当前类中的serialVersionUID是否一致，如果不一致，就会抛出InvalidClassException异常，阻止序列化。
```java
@Data
@Accessors(chain = true)
public class UserPwdLoginReq implements Serializable {

    /**
     * serialVersionUID是一个long类型的常量，用于标识序列化对象的版本号。如果没有显式声明，则JVM会依据类的特定信息自动生成一个。
     * 自动生成serialVersionUID存在一定风险，因为它高度依赖类的结构，一旦类的结构发生细微变化，则serialVersionUID值就可能改变。
     */
    private static final long serialVersionUID = 2139742660700910738L;
    /**
     * 用户id
     */
    private Long userId;
    /**
     * 登录用户名
     */
    private String username;
}
```
Serializable接口的作用有以下几个方面：
- 持久化：将对象保存到磁盘或者数据库中，以便后续读取。
- 网络传输：将对象通过网络传输给其他机器。
- 缓存：将对象存储在缓存中，以便后续读取。
- 分布式系统：将对象作为消息传递给其他进程。


# Lombok链式调用注解
@Accessors(chain = true) 是Lombok提供的一个注解，用于生成getter和setter方法，并且支持链式调用。
```java
UserPwdLoginReq req = new UserPwdLoginReq()
    .setUserId(1L)
    .setUsername("testUser")
    .setPassword("testPassword")
    .setStarNumber("123456")
    .setInvitationCode("ABCDEF");
```


# 用户上下文信息
TransmittableThreadLocal是阿里巴巴开源的TransmittableThreadLocal(TTL)库中的类，它是ThreadLocal的增强版。

ThreadLocal可以为每个线程提供独立的变量副本，而TransmittableThreadLocal在此基础上还支持在跨线程传递时保持变量的一致性，比如在使用线程池的场景下，指定泛型为ReqInfo，表示该TransmittableThreadLocal存储的是ReqInfo类型的对象。
```java
/**
 * 请求上下文，携带用户身份相关信息
 *
 * @author YiHui
 * @date 2022/7/6
 */
public class ReqInfoContext {

    // 主要作用是为每个线程提供一个独立的ReqInfo对象存储区域，并且支持在跨线程场景下传递、存储、清除ReqInfo对象信息。
    private static TransmittableThreadLocal<ReqInfo> contexts = new TransmittableThreadLocal<>();

    public static void addReqInfo(ReqInfo reqInfo) {
        contexts.set(reqInfo);
    }

    public static void clear() {
        contexts.remove();
    }

    public static ReqInfo getReqInfo() {
        return contexts.get();
    }

    @Data
    public static class ReqInfo implements Principal {
        /**
         * appKey
         */
        private String appKey;
        /**
         * 访问的域名
         */
        private String host;
        /**
         * 访问路径
         */
        private String path;
        /**
         * 客户端ip
         */
        private String clientIp;
        /**
         * referer
         */
        private String referer;
        /**
         * post 表单参数
         */
        private String payload;
        /**
         * 设备信息
         */
        private String userAgent;

        /**
         * 登录的会话
         */
        private String session;

        /**
         * 用户id
         */
        private Long userId;
        /**
         * 用户信息
         */
        private BaseUserInfoDTO user;
        /**
         * 消息数量
         */
        private Integer msgNum;

        private Seo seo;

        private String deviceId;

        /**
         * 当前聊天的会话id
         */
        private String chatId;

        @Override
        public String getName() {
            return session;
        }
    }
}
```


# SpringUtil工具类
SpringUtil工具实现了ApplicationContextAware和EnvironmentAware接口，用于在非Spring管理的类中方便地获取Spring容器地上下文、Bean实例以及配置信息，同时还能发布Spring事件。
```java
/**
 * 实现ApplicationContextAware接口的类能获取Spring应用上下文ApplicationContext
 * 实现EnvironmentAware接口的类能获取Spring环境变量Environment
 * 
 * @author YiHui
 * @date 2022/8/29
 */
@Component
public class SpringUtil implements ApplicationContextAware, EnvironmentAware {
    
    // 存储应用上下文，volatile关键字保证多线程环境下变量的可见性
    private volatile static ApplicationContext context;
    // 存储Spring环境信息，同样使用了volatile关键字
    private volatile static Environment environment;
    // 用于配置绑定，可将配置属性绑定到Java对象
    private static Binder binder;

    /**
     * Spring容器自动调用该方法，将应用上下文注入到context变量
     * 
     * @param applicationContext
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringUtil.context = applicationContext;
    }

    @Override
    public void setEnvironment(Environment environment) {
        SpringUtil.environment = environment;
        binder = Binder.get(environment);
    }

    public static ApplicationContext getContext() {
        return context;
    }

    /**
     * 获取bean
     *
     * @param bean
     * @param <T>
     * @return
     */
    public static <T> T getBean(Class<T> bean) {
        if (context != null) {
            return context.getBean(bean);
        } else {
            throw new IllegalStateException("Spring ApplicationContext is not active or has been closed.");
        }
    }

    public static <T> T getBeanOrNull(Class<T> bean) {
        try {
            return context.getBean(bean);
        } catch (Exception e) {
            return null;
        }
    }

    public static Object getBean(String beanName) {
        return context.getBean(beanName);
    }

    public static Object getBeanOrNull(String beanName) {
        try {
            return context.getBean(beanName);
        } catch (Exception e) {
            return null;
        }
    }

    public static boolean hasConfig(String key) {
        return environment.containsProperty(key);
    }

    /**
     * 获取配置
     *
     * @param key
     * @return
     */
    public static String getConfig(String key) {
        return environment.getProperty(key);
    }

    public static String getConfigOrElse(String mainKey, String slaveKey) {
        String ans = environment.getProperty(mainKey);
        if (ans == null) {
            return environment.getProperty(slaveKey);
        }
        return ans;
    }

    /**
     * 获取配置
     *
     * @param key
     * @param val 配置不存在时的默认值
     * @return
     */
    public static String getConfig(String key, String val) {
        return environment.getProperty(key, val);
    }

    /**
     * 发布事件消息
     *
     * @param event
     */
    public static void publishEvent(ApplicationEvent event) {
        context.publishEvent(event);
    }


    /**
     * 配置绑定类
     *
     * @return
     */
    public static Binder getBinder() {
        return binder;
    }
}
```