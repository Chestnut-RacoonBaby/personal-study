# MyBatisPlus使用
查询一条数据时，可以使用.last("limit 1")，这样可以避免查询出多条数据，但是需要注意的是，使用last("limit 1")可能会导致查询效率低下，因为它会查询出所有数据，然后再取第一条数据，所以在使用时需要注意。
```java
public UserDO getUserByUserName(String userName) {
    LambdaQueryWrapper<UserDO> queryUser = Wrappers.lambdaQuery();
    queryUser.eq(UserDO::getUserName, userName)
            .eq(UserDO::getDeleted, YesOrNoEnum.NO.getCode())
            .last("limit 1");
    return userMapper.selectOne(queryUser);
}
```

# 实体类字段上注解
@TableId 是MyBatisPlus框架提供的注解，用于指定数据库表的主键字段，IdType代表不同的主键生成策略。
```java
@TableId(type = IdType.AUTO)
private Long id;
```
IdType的取值如下：
- AUTO(0)：自动生成主键，根据数据库的自增策略来生成主键。
- NONE(1)：不指定主键，由开发者手动设置主键。
- INPUT(2)：由开发者手动输入主键值。
- ASSIGN_ID(3)：使用雪花算法生成主键，并将主键转换为字符串类型。
- ASSIGN_UUID(4)：使用UUID生成主键，并将主键转换为字符串类型。


# Serializable接口
Serializable接口是Java语言提供的一个接口，用于标识一个类可以进行序列化。Serializable接口本身没有定义任何方法，它只是一个标记接口，用于告诉JVM这个类可以被序列化。
当一个类实现了Serializable接口后，它的对象就可以被序列化和反序列化。序列化是将对象转换为字节流的过程，反序列化是将字节流转换为对象的过程。

在反序列化时，Java虚拟机会比较序列化对象中的serialVersionUID和当前类中的serialVersionUID是否一致，如果不一致，就会抛出InvalidClassException异常，阻止序列化。
```java
@Data
@Accessors(chain = true)
public class UserPwdLoginReq implements Serializable {

    /**
     * serialVersionUID是一个long类型的常量，用于标识序列化对象的版本号。如果没有显式声明，则JVM会依据类的特定信息自动生成一个。
     * 自动生成serialVersionUID存在一定风险，因为它高度依赖类的结构，一旦类的结构发生细微变化，则serialVersionUID值就可能改变。
     */
    private static final long serialVersionUID = 2139742660700910738L;
    /**
     * 用户id
     */
    private Long userId;
    /**
     * 登录用户名
     */
    private String username;
}
```
Serializable接口的作用有以下几个方面：
- 持久化：将对象保存到磁盘或者数据库中，以便后续读取。
- 网络传输：将对象通过网络传输给其他机器。
- 缓存：将对象存储在缓存中，以便后续读取。
- 分布式系统：将对象作为消息传递给其他进程。


# Lombok链式调用注解
@Accessors(chain = true) 是Lombok提供的一个注解，用于生成getter和setter方法，并且支持链式调用。
```java
UserPwdLoginReq req = new UserPwdLoginReq()
    .setUserId(1L)
    .setUsername("testUser")
    .setPassword("testPassword")
    .setStarNumber("123456")
    .setInvitationCode("ABCDEF");
```