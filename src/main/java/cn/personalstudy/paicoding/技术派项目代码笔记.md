# MyBatisPlus使用
查询一条数据时，可以使用.last("limit 1")，这样可以避免查询出多条数据，但是需要注意的是，使用last("limit 1")可能会导致查询效率低下，因为它会查询出所有数据，然后再取第一条数据，所以在使用时需要注意。
```java
public UserDO getUserByUserName(String userName) {
    LambdaQueryWrapper<UserDO> queryUser = Wrappers.lambdaQuery();
    queryUser.eq(UserDO::getUserName, userName)
            .eq(UserDO::getDeleted, YesOrNoEnum.NO.getCode())
            .last("limit 1");
    return userMapper.selectOne(queryUser);
}
```

# 实体类字段上注解
@TableId 是MyBatisPlus框架提供的注解，用于指定数据库表的主键字段，IdType代表不同的主键生成策略。
```java
@TableId(type = IdType.AUTO)
private Long id;
```
IdType的取值如下：
- AUTO(0)：自动生成主键，根据数据库的自增策略来生成主键。
- NONE(1)：不指定主键，由开发者手动设置主键。
- INPUT(2)：由开发者手动输入主键值。
- ASSIGN_ID(3)：使用雪花算法生成主键，并将主键转换为字符串类型。
- ASSIGN_UUID(4)：使用UUID生成主键，并将主键转换为字符串类型。


# Serializable接口
Serializable接口是Java语言提供的一个接口，用于标识一个类可以进行序列化。Serializable接口本身没有定义任何方法，它只是一个标记接口，用于告诉JVM这个类可以被序列化。
当一个类实现了Serializable接口后，它的对象就可以被序列化和反序列化。序列化是将对象转换为字节流的过程，反序列化是将字节流转换为对象的过程。

在反序列化时，Java虚拟机会比较序列化对象中的serialVersionUID和当前类中的serialVersionUID是否一致，如果不一致，就会抛出InvalidClassException异常，阻止序列化。
```java
@Data
@Accessors(chain = true)
public class UserPwdLoginReq implements Serializable {

    /**
     * serialVersionUID是一个long类型的常量，用于标识序列化对象的版本号。如果没有显式声明，则JVM会依据类的特定信息自动生成一个。
     * 自动生成serialVersionUID存在一定风险，因为它高度依赖类的结构，一旦类的结构发生细微变化，则serialVersionUID值就可能改变。
     */
    private static final long serialVersionUID = 2139742660700910738L;
    /**
     * 用户id
     */
    private Long userId;
    /**
     * 登录用户名
     */
    private String username;
}
```
Serializable接口的作用有以下几个方面：
- 持久化：将对象保存到磁盘或者数据库中，以便后续读取。
- 网络传输：将对象通过网络传输给其他机器。
- 缓存：将对象存储在缓存中，以便后续读取。
- 分布式系统：将对象作为消息传递给其他进程。


# Lombok链式调用注解
@Accessors(chain = true) 是Lombok提供的一个注解，用于生成getter和setter方法，并且支持链式调用。
```java
UserPwdLoginReq req = new UserPwdLoginReq()
    .setUserId(1L)
    .setUsername("testUser")
    .setPassword("testPassword")
    .setStarNumber("123456")
    .setInvitationCode("ABCDEF");
```


# 用户上下文信息
TransmittableThreadLocal是阿里巴巴开源的TransmittableThreadLocal(TTL)库中的类，它是ThreadLocal的增强版。

ThreadLocal可以为每个线程提供独立的变量副本，而TransmittableThreadLocal在此基础上还支持在跨线程传递时保持变量的一致性，比如在使用线程池的场景下，指定泛型为ReqInfo，表示该TransmittableThreadLocal存储的是ReqInfo类型的对象。
```java
/**
 * 请求上下文，携带用户身份相关信息
 *
 * @author YiHui
 * @date 2022/7/6
 */
public class ReqInfoContext {

    // 主要作用是为每个线程提供一个独立的ReqInfo对象存储区域，并且支持在跨线程场景下传递、存储、清除ReqInfo对象信息。
    private static TransmittableThreadLocal<ReqInfo> contexts = new TransmittableThreadLocal<>();

    public static void addReqInfo(ReqInfo reqInfo) {
        contexts.set(reqInfo);
    }

    public static void clear() {
        contexts.remove();
    }

    public static ReqInfo getReqInfo() {
        return contexts.get();
    }

    @Data
    public static class ReqInfo implements Principal {
        /**
         * appKey
         */
        private String appKey;
        /**
         * 访问的域名
         */
        private String host;
        /**
         * 访问路径
         */
        private String path;
        /**
         * 客户端ip
         */
        private String clientIp;
        /**
         * referer
         */
        private String referer;
        /**
         * post 表单参数
         */
        private String payload;
        /**
         * 设备信息
         */
        private String userAgent;

        /**
         * 登录的会话
         */
        private String session;

        /**
         * 用户id
         */
        private Long userId;
        /**
         * 用户信息
         */
        private BaseUserInfoDTO user;
        /**
         * 消息数量
         */
        private Integer msgNum;

        private Seo seo;

        private String deviceId;

        /**
         * 当前聊天的会话id
         */
        private String chatId;

        @Override
        public String getName() {
            return session;
        }
    }
}
```